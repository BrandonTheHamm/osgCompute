/* osgCompute - Copyright (C) 2008-2009 SVT Group
*
* This library is free software; you can redistribute it and/or modify
* it under the terms of the GNU Lesser General Public License as
* published by the Free Software Foundation; either version 3 of
* the License, or (at your option) any later version.
*
* This library is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU Lesse General Public License for more details.
*
* The full license is in LICENSE file included with this distribution.
*/

#ifndef OSGCUDA_TEXTURERECTANGLE
#define OSGCUDA_TEXTURERECTANGLE 1

#include <osg/TextureRectangle>
#include <osgCuda/Texture>

namespace osgCuda
{
    template<class T>
    class TextureRectangle;

    typedef TextureRectangle<unsigned char>                                      UByteTextureRectangle;
    typedef TextureRectangle<osg::Vec4ub>                                        Vec4ubTextureRectangle;
    typedef TextureRectangle<char>                                               ByteTextureRectangle;
    typedef TextureRectangle<osg::Vec2b>                                         Vec2bTextureRectangle;
    typedef TextureRectangle<osg::Vec3b>                                         Vec3bTextureRectangle;
    typedef TextureRectangle<osg::Vec4b>                                         Vec4bTextureRectangle;
    typedef TextureRectangle<unsigned short>                                     UShortTextureRectangle;
    typedef TextureRectangle<short>                                              ShortTextureRectangle;
    typedef TextureRectangle<osg::Vec2s>                                         Vec2sTextureRectangle;
    typedef TextureRectangle<osg::Vec3s>                                         Vec3sTextureRectangle;
    typedef TextureRectangle<osg::Vec4s>                                         Vec4sTextureRectangle;
    typedef TextureRectangle<unsigned int>                                       UIntTextureRectangle;
    typedef TextureRectangle<int>                                                IntTextureRectangle;
    typedef TextureRectangle<float>                                              FloatTextureRectangle;
    typedef TextureRectangle<osg::Vec2f>                                         Vec2fTextureRectangle;
    typedef TextureRectangle<osg::Vec3f>                                         Vec3fTextureRectangle;
    typedef TextureRectangle<osg::Vec4f>                                         Vec4fTextureRectangle;
    typedef TextureRectangle<double>                                             DoubleTextureRectangle;
    typedef TextureRectangle<osg::Vec2d>                                         Vec2dTextureRectangle;
    typedef TextureRectangle<osg::Vec3d>                                         Vec3dTextureRectangle;
    typedef TextureRectangle<osg::Vec4d>                                         Vec4dTextureRectangle;

    /**
    */
    template< class DATATYPE >
    class TextureRectangle : public Texture<DATATYPE>, public osg::TextureRectangle
    {
    public:
        TextureRectangle();

        META_Texture( osgCuda, TextureRectangle )

        virtual bool init();

        virtual void apply(osg::State& state) const;
        virtual void releaseGLObjects(osg::State* state=0) const;

        virtual void clear();

    protected:
        virtual ~TextureRectangle();
        void clearLocal();

        virtual bool initDimension();

        virtual bool allocPBO( TextureStream<DATATYPE>& stream ) const;
        virtual void syncPBO( TextureStream<DATATYPE>& stream ) const;
        virtual void syncTexture( TextureStream<DATATYPE>& stream ) const;

        virtual osgCompute::BufferStream* newStream( const osgCompute::Context& context ) const;
    private:
        // copy constructor and operator should not be called
        TextureRectangle( const TextureRectangle& , const osg::CopyOp& ) {}
        TextureRectangle& operator=(const TextureRectangle&) { return (*this); }
    };

    /////////////////////////////////////////////////////////////////////////////////////////////////
    // PUBLIC FUNCTIONS /////////////////////////////////////////////////////////////////////////////
    /////////////////////////////////////////////////////////////////////////////////////////////////
    //------------------------------------------------------------------------------
    template< class DATATYPE >
    TextureRectangle<DATATYPE>::TextureRectangle()
        : osgCuda::Texture<DATATYPE>(),
          osg::TextureRectangle()
    {
        clearLocal();
    }

    //------------------------------------------------------------------------------
    template< class DATATYPE >
    TextureRectangle<DATATYPE>::~TextureRectangle()
    {
        clearLocal();
    }

    //------------------------------------------------------------------------------
    template< class DATATYPE >
    void TextureRectangle<DATATYPE>::clear()
    {
        osgCuda::Texture<DATATYPE>::clear();
        clearLocal();
    }

    //------------------------------------------------------------------------------
    template< class DATATYPE >
    bool TextureRectangle<DATATYPE>::init()
    {
        return osgCuda::Texture<DATATYPE>::init();
    }

    //------------------------------------------------------------------------------
    template< class DATATYPE >
    void TextureRectangle<DATATYPE>::releaseGLObjects( osg::State* state/*=0*/ ) const
    {
        if( state != NULL )
        {
            const osgCompute::Context* curCtx = this->getContext( state->getContextID() );
            if( curCtx )
            {
                if( osgCompute::Buffer::getMapping( *curCtx ) != osgCompute::UNMAPPED )
                    this->unmap( *curCtx );
            }
        }

        osg::TextureRectangle::releaseGLObjects( state );
    }

    //------------------------------------------------------------------------------
    template< class DATATYPE >
    void TextureRectangle<DATATYPE>::apply( osg::State& state ) const
    {
        const osgCompute::Context* curCtx = this->getContext( state.getContextID() );
        if( curCtx )
        {
            if( osgCompute::Buffer::getMapping( *curCtx ) != osgCompute::UNMAPPED )
                this->unmap( *curCtx );
        }

        osg::TextureRectangle::apply( state );
    }

    //------------------------------------------------------------------------------
    template< class DATATYPE >
    bool TextureRectangle<DATATYPE>::initDimension()
    {
        if( osgCompute::Buffer::getNumDimensions() != 0 )
        {
            setTextureWidth( osgCompute::Buffer::getDimension(0) );
            setTextureHeight( osgCompute::Buffer::getDimension(1) );
        }
        else
        {
            if( getImage(0) && getTextureWidth() == 0)
                setTextureWidth( getImage(0)->s() );

            if( getImage(0) && getTextureHeight() == 0)
                setTextureHeight( getImage(0)->t() );

            osgCompute::Buffer::setDimension(0, getTextureWidth() );
            osgCompute::Buffer::setDimension(1, getTextureHeight() );
        }

        return osgCuda::Texture<DATATYPE>::initDimension();
    }

    /////////////////////////////////////////////////////////////////////////////////////////////////
    // PROTECTED FUNCTIONS //////////////////////////////////////////////////////////////////////////
    /////////////////////////////////////////////////////////////////////////////////////////////////
    //------------------------------------------------------------------------------
    template< class DATATYPE >
    void TextureRectangle<DATATYPE>::clearLocal()
    {
    }

    //------------------------------------------------------------------------------
    template< class DATATYPE >
    void TextureRectangle<DATATYPE>::syncTexture( TextureStream<DATATYPE>& stream ) const
    {
        if( stream._bo == UINT_MAX )
            return;

        osg::BufferObject::Extensions* bufferExt = osg::BufferObject::getExtensions( stream._context->getId(),true );
        if( !bufferExt )
        {
            osg::notify(osg::FATAL)
                << "CUDA::TextureRectangle::syncTexture() for texture \""
                << osg::Object::getName()<< "\": cannot find required extension for context \""<<stream._context->getId()<<"\"."
                << std::endl;

            return;
        }

        osg::Texture::TextureObject* tex = osg::Texture::getTextureObject( stream._context->getId() );
        if( !tex )
        {
            osg::notify(osg::FATAL)
                << "CUDA::TextureRectangle::syncTexture() for texture \""
                << osg::Object::getName()<< "\": texture object not allocated for context \""<<stream._context->getId()<<"\"."
                << std::endl;

            return;
        }

        GLenum texType = GL_NONE;
        if( osg::Texture::getInternalFormatMode() == osg::Texture::USE_IMAGE_DATA_FORMAT )
        {
            if( !getImage() )
                return;

            texType = getImage()->getDataType();
        }
        else
        {
            texType = osg::Texture::getSourceType();
        }

        bufferExt->glBindBuffer( GL_PIXEL_UNPACK_BUFFER_ARB,  stream._bo );
        glBindTexture( GL_TEXTURE_RECTANGLE, tex->_id );

        // unpack data
        glTexSubImage2D(
                    GL_TEXTURE_RECTANGLE, 0, 0, 0,
                    osgCompute::Buffer::getDimension(0),
                    osgCompute::Buffer::getDimension(1),
                    tex->_internalFormat,
                    texType,
                    NULL );

        GLenum errorStatus = glGetError();
        if( errorStatus != GL_NO_ERROR )
        {
            osg::notify(osg::FATAL)
                << "CUDA::TextureRectangle::syncTexture() for buffer \""
                << osg::Object::getName()<< "\": something goes wrong on glTex(Sub)ImageXD() for context \""
                << stream._context->getId()<<"\". Returned code is "
                << std::hex<<errorStatus<<"."
                << std::endl;
        }


        glBindTexture( GL_TEXTURE_RECTANGLE, 0 );
        bufferExt->glBindBuffer( GL_PIXEL_UNPACK_BUFFER_ARB, 0 );
    }

    //------------------------------------------------------------------------------
    template< class DATATYPE >
    void TextureRectangle<DATATYPE>::syncPBO( TextureStream<DATATYPE>& stream ) const
    {
        if( stream._bo == UINT_MAX )
            return;

        osg::BufferObject::Extensions* bufferExt = osg::BufferObject::getExtensions( stream._context->getId(),true );
        if( !bufferExt )
        {
            osg::notify(osg::FATAL)
                << "CUDA::TextureRectangle::syncPBO() for texture \""
                << osg::Object::getName()<< "\": cannot find required extension for context \""<<stream._context->getId()<<"\"."
                << std::endl;

            return;
        }

        osg::Texture::TextureObject* tex = osg::Texture::getTextureObject( stream._context->getId() );
        if( !tex )
        {
            osg::notify(osg::FATAL)
                << "CUDA::TextureRectangle::syncPBO() for texture \""
                << osg::Object::getName()<< "\": texture object not allocated for context \""<<stream._context->getId()<<"\"."
                << std::endl;

            return;
        }

        GLenum texType = GL_NONE;
        if( osg::Texture::getInternalFormatMode() == osg::Texture::USE_IMAGE_DATA_FORMAT &&
            getImage() )
        {
            texType = getImage()->getDataType();
        }
        else
        {
            texType = osg::Texture::getSourceType();
        }

        if( texType == GL_NONE )
        {
            osg::notify(osg::FATAL)
                << "CUDA::TextureRectangle::syncPBO() for texture \""
                << osg::Object::getName()<< "\": texture type unknown."
                << std::endl;

            return;
        }

        ////////////////////
        // UNREGISTER PBO //
        ////////////////////
        cudaError res = cudaGLUnregisterBufferObject( stream._bo );
        if( cudaSuccess != res )
        {
            osg::notify(osg::FATAL)
                << "CUDA::TextureRectangle::syncPBO() for texture \""
                << osg::Object::getName()<< "\": something goes wrong on cudaGLUnregisterBufferObject() for context \""
                << stream._context->getId()<<"\". Returned code is "
				<< std::hex<<res<<" ("<<cudaGetErrorString(cudaGetLastError())<<")."
                << std::endl;

            return;
        }

        ///////////////
        // COPY DATA //
        ///////////////
        glBindTexture( GL_TEXTURE_RECTANGLE, tex->_id );
        bufferExt->glBindBuffer( GL_PIXEL_PACK_BUFFER_ARB,  stream._bo );

        // pack data
        glGetTexImage( GL_TEXTURE_RECTANGLE, 0, tex->_internalFormat, texType, NULL );

        GLenum errorStatus = glGetError();
        if( errorStatus != GL_NO_ERROR )
        {
            osg::notify(osg::FATAL)
                << "CUDA::TextureRectangle::syncPBO() for texture \""
                << osg::Object::getName()<< "\": something goes wrong on glGetTexImage() for context \""
                << stream._context->getId()<<"\". Returned code is "
                << std::hex<<errorStatus<<"."
                << std::endl;
        }

        bufferExt->glBindBuffer( GL_PIXEL_PACK_BUFFER_ARB, 0 );
        glBindTexture( GL_TEXTURE_RECTANGLE, 0 );

        ////////////////////////
        // REGISTER PBO AGAIN //
        ////////////////////////
        res = cudaGLRegisterBufferObject( stream._bo );
        if( cudaSuccess != res )
        {
            osg::notify(osg::FATAL)
                << "CUDA::TextureRectangle::syncPBO() for texture \""
                << osg::Object::getName()<< "\": something goes wrong on cudaGLRegisterBufferObject() for context \""
                << stream._context->getId()<<"\". Returned code is "
                << std::hex<<res<<" ("<<cudaGetErrorString(cudaGetLastError())<<")."
                << std::endl;
        }

        stream._syncHost = true;
    }

    //------------------------------------------------------------------------------
    template< class DATATYPE >
    bool TextureRectangle<DATATYPE>::allocPBO( TextureStream<DATATYPE>& stream ) const
    {
        /////////////////////
        // COMPILE TEXTURE //
        /////////////////////
        osg::BufferObject::Extensions* bufferExt = osg::BufferObject::getExtensions( stream._context->getId(), true );
        if( !bufferExt )
        {
            osg::notify(osg::FATAL)
                << "CUDA::TextureRectangle::allocPBO() for texture \""
                << osg::Object::getName()<< "\": cannot find required extension for context \""<<stream._context->getId()<<"\"."
                << std::endl;

            return false;
        }

        osg::Texture::TextureObject* tex = osg::Texture::getTextureObject( stream._context->getId() );
        if( !tex )
        {
            apply( *stream._context->getState() );
            glBindTexture( GL_TEXTURE_RECTANGLE, 0 );
        }

        // second chance
        tex = osg::Texture::getTextureObject( stream._context->getId() );
        if( !tex )
        {

            osg::notify(osg::FATAL)
                << "CUDA::TextureRectangle::allocPBO() for texture \""
                << osg::Object::getName()<< "\": texture object not allocated for context \""<<stream._context->getId()<<"\"."
                << std::endl;

            return false;
        }

        GLenum texType = GL_NONE;
        if( osg::Texture::getInternalFormatMode() == osg::Texture::USE_IMAGE_DATA_FORMAT &&
            getImage() )
        {
            texType = getImage()->getDataType();
        }
        else
        {
            texType = osg::Texture::getSourceType();
        }

        if( texType == GL_NONE )
        {
            osg::notify(osg::FATAL)
                << "CUDA::TextureRectangle::allocPBO() for texture \""
                << osg::Object::getName()<< "\": texture type unknown."
                << std::endl;

            return false;
        }

        ///////////////
        // SETUP PBO //
        ///////////////
        stream._bo = static_cast<const Context*>( stream._context.get() )->mallocBufferObject( osgCompute::Buffer::getByteSize() );
        if( UINT_MAX == stream._bo )
        {
            osg::notify(osg::FATAL)
                << "CUDA::TextureRectangle::allocPBO() for Buffer \""
                << osg::Object::getName()<< "\": Could not generate buffer object (glGenBuffers()) for context \""
                << stream._context->getId()<<"\"."
                << std::endl;

            return false;
        }
        stream._boRegistered = true;

        ///////////////////
        // SETUP TEXTURE //
        ///////////////////
        if( tex->isAllocated() )
        {
            //////////////
            // SYNC PBO //
            //////////////
            // Sync PBO with texture data if texture is allocated
            syncPBO( stream );
        }
        else if( !this->getIsRenderTarget() )
        {
            /////////////////////////////
            // ALLOCATE TEXTURE MEMORY //
            /////////////////////////////
            // else allocate the memory.
            glBindTexture( GL_TEXTURE_RECTANGLE, tex->_id );

            // Allocate memory for texture if not done so far
            glTexImage2D(
                GL_TEXTURE_RECTANGLE, 0,
                tex->_internalFormat,
                tex->_width, tex->_height,
                tex->_border,
                tex->_internalFormat, texType, NULL );

            GLenum errorNo = glGetError();
            if( errorNo != GL_NO_ERROR )
            {
                osg::notify(osg::FATAL)
                    << "CUDA::TextureRectangle::allocPBO() for buffer \""
                    << osg::Object::getName()<< "\": something goes wrong on glTexImageXD() for context \""
                    << stream._context->getId()<<"\". Returned code is "
                    << std::hex<<errorNo<<"."
                    << std::endl;

                glBindTexture( GL_TEXTURE_RECTANGLE, 0 );
                bufferExt->glBindBuffer( GL_PIXEL_UNPACK_BUFFER_ARB, 0 );
                return false;
            }

            glBindTexture( GL_TEXTURE_RECTANGLE, 0 );

            // Mark context based texture object as allocated
            tex->setAllocated( true );
        }

        return true;
    }

    //------------------------------------------------------------------------------
    template< class DATATYPE >
    osgCompute::BufferStream* TextureRectangle<DATATYPE>::newStream( const osgCompute::Context& context ) const
    {
        return new TextureStream<DATATYPE>;
    }
}


#endif //OSGCUDA_TEXTURERECTANGLE
