/* osgCompute - Copyright (C) 2008-2009 SVT Group
*
* This library is free software; you can redistribute it and/or modify
* it under the terms of the GNU Lesser General Public License as
* published by the Free Software Foundation; either version 3 of
* the License, or (at your option) any later version.
*
* This library is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU Lesse General Public License for more details.
*
* The full license is in LICENSE file included with this distribution.
*/

#ifndef OSGCUDA_ARRAY
#define OSGCUDA_ARRAY 1


#include <driver_types.h>
#include <osg/Image>
#include <osg/Array>
#include <osgCompute/Memory>
#include <osgCuda/Export>

namespace osgCuda
{
    /**
    */
    class ArrayObject : public osgCompute::MemoryObject
    {
    public:
        cudaArray*                      _devArray;
        void*							_hostPtr;
        unsigned int                    _modifyCount;

        ArrayObject();
        virtual ~ArrayObject();

    private:
        // not allowed to call copy-constructor or copy-operator
        ArrayObject( const ArrayObject& ) {}
        ArrayObject& operator=( const ArrayObject& ) { return *this; }
    };

    /**
    */
    class LIBRARY_EXPORT Array : public osgCompute::Memory
    {
    public:
        Array();

        META_Object(osgCuda,Array)

        virtual bool init();
        virtual void clear();

        virtual void* map( unsigned int mapping = osgCompute::MAP_DEVICE, unsigned int offset = 0, unsigned int hint = 0 );
        virtual void unmap( unsigned int hint = 0 );	
        virtual bool reset( unsigned int hint = 0 );

        virtual void setImage( osg::Image* image );
        virtual osg::Image* getImage();
        virtual const osg::Image* getImage() const;

        virtual void setArray( osg::Array* array );
        virtual osg::Array* getArray();
        virtual const osg::Array* getArray() const;

        virtual void setChannelFormatDesc(cudaChannelFormatDesc& channelFormatDesc);
        virtual cudaChannelFormatDesc& getChannelFormatDesc();
        virtual const cudaChannelFormatDesc& getChannelFormatDesc() const;

    protected:
        virtual ~Array() { clearLocal(); }
        void clearLocal();

        bool setup( unsigned int mapping );
        bool alloc( unsigned int mapping );
        bool sync( unsigned int mapping );

        virtual osgCompute::MemoryObject* createObject() const;
        virtual unsigned int computePitch() const;
        void resetModifiedCounts() const;

        osg::ref_ptr<osg::Array>     _array;
        osg::ref_ptr<osg::Image>     _image;

        cudaChannelFormatDesc                _channelFormatDesc;

    private:
        // copy constructor and operator should not be called
        Array( const Array&, const osg::CopyOp& ) {}
        Array& operator=( const Array& copy ) { return (*this); }
    };
}

#endif //OSGCUDA_ARRAY
