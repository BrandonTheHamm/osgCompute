/* osgCompute - Copyright (C) 2008-2009 SVT Group
 *
 * This library is free software; you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 3 of
 * the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesse General Public License for more details.
 *
 * The full license is in LICENSE file included with this distribution.
*/

#ifndef OSGCUDA_BUFFER
#define OSGCUDA_BUFFER 1

#include <osgCuda/Context>
#include <cuda_runtime.h>
#include <driver_types.h>
#include <osg/Image>
#include <osg/Array>
#include <osgCompute/Buffer>
#include <osgCuda/Export>

namespace osg
{
    class Vec2b;
    class Vec3b;
    class Vec4b;
    class Vec4ub;
    class Vec2s;
    class Vec3s;
    class Vec4s;
    class Vec2f;
    class Vec3f;
    class Vec4f;
    class Vec2d;
    class Vec3d;
    class Vec4d;
}

namespace osgCuda
{
    template<class T>
    class Buffer;

    typedef Buffer<unsigned char>     UByteBuffer;
    typedef Buffer<osg::Vec4ub>       Vec4ubBuffer;
    typedef Buffer<char>              ByteBuffer;
    typedef Buffer<osg::Vec2b>        Vec2bBuffer;
    typedef Buffer<osg::Vec3b>        Vec3bBuffer;
    typedef Buffer<osg::Vec4b>        Vec4bBuffer;
    typedef Buffer<unsigned short>    UShortBuffer;
    typedef Buffer<short>             ShortBuffer;
    typedef Buffer<osg::Vec2s>        Vec2sBuffer;
    typedef Buffer<osg::Vec3s>        Vec3sBuffer;
    typedef Buffer<osg::Vec4s>        Vec4sBuffer;
    typedef Buffer<unsigned int>      UIntBuffer;
    typedef Buffer<int>               IntBuffer;
    typedef Buffer<unsigned long>     ULongBuffer;
    typedef Buffer<long>              LongBuffer;
    typedef Buffer<float>             FloatBuffer;
    typedef Buffer<osg::Vec2f>        Vec2fBuffer;
    typedef Buffer<osg::Vec3f>        Vec3fBuffer;
    typedef Buffer<osg::Vec4f>        Vec4fBuffer;
    typedef Buffer<double>            DoubleBuffer;
    typedef Buffer<osg::Vec2d>        Vec2dBuffer;
    typedef Buffer<osg::Vec3d>        Vec3dBuffer;
    typedef Buffer<osg::Vec4d>        Vec4dBuffer;

    /**
    */
	template< class DATATYPE >
    class BufferStream : public osgCompute::BufferStream
    {
    public:
        DATATYPE*                       _devPtr;
        bool                            _devPtrAllocated;
        bool                            _syncDevice;
        DATATYPE*                       _hostPtr;
        bool                            _hostPtrAllocated;
        bool                            _syncHost;
        unsigned int                    _modifyCount;

        BufferStream();
        virtual ~BufferStream();

    private:
        // not allowed to call copy-constructor or copy-operator
        BufferStream( const BufferStream& ) {}
        BufferStream& operator=( const BufferStream& ) { return *this; }
    };

	/////////////////////////////////////////////////////////////////////////////////////////////////
	// PUBLIC FUNCTIONS /////////////////////////////////////////////////////////////////////////////
	/////////////////////////////////////////////////////////////////////////////////////////////////
	//------------------------------------------------------------------------------
	template< class DATATYPE >
	BufferStream<DATATYPE>::BufferStream()
		:   osgCompute::BufferStream(),
            _devPtr(NULL),
			_hostPtr(NULL),
			_syncDevice(false),
			_syncHost(false),
            _devPtrAllocated(false),
            _hostPtrAllocated(false),
            _modifyCount(UINT_MAX)
	{
	}

	//------------------------------------------------------------------------------
	template< class DATATYPE >
	BufferStream<DATATYPE>::~BufferStream()
	{
        if( _devPtrAllocated && NULL != _devPtr)
            static_cast<Context*>(osgCompute::BufferStream::_context.get())->freeMemory( _devPtr );
        if( _hostPtrAllocated && NULL != _hostPtr)
            static_cast<Context*>(osgCompute::BufferStream::_context.get())->freeMemory( _hostPtr );
	}

    /**
	*/
	template< class DATATYPE >
    class Buffer : public osgCompute::Buffer, public osg::Object
    {

    public:
        Buffer();

        META_Buffer( osgCuda, Buffer )

        virtual bool init();
        virtual void clear();

        virtual bool setMemory( const osgCompute::Context& context, int value, unsigned int mapping ) const;
        virtual void* map( const osgCompute::Context& context, unsigned int mapping ) const;
        virtual void unmap( const osgCompute::Context& context ) const;
        virtual unsigned int getElementSize() const { return sizeof(DATATYPE); }

        virtual void setImage( osg::Image* image );
        virtual osg::Image* getImage();
        virtual const osg::Image* getImage() const;

        virtual void setArray( osg::Array* array );
        virtual osg::Array* getArray();
        virtual const osg::Array* getArray() const;

    protected:
        virtual ~Buffer() { clearLocal(); }
        void clearLocal();

        virtual DATATYPE* mapStream( BufferStream<DATATYPE>& stream, unsigned int mapping ) const;
        virtual void unmapStream( BufferStream<DATATYPE>& stream ) const;

        bool setupStream( unsigned int mapping, BufferStream<DATATYPE>& stream ) const;
        bool allocStream( unsigned int mapping, BufferStream<DATATYPE>& stream ) const;
        bool syncStream( unsigned int mapping, BufferStream<DATATYPE>& stream ) const;

        virtual osgCompute::BufferStream* newStream( const osgCompute::Context& context ) const;

    protected:
        mutable osg::ref_ptr<osg::Array>     _array;
        mutable osg::ref_ptr<osg::Image>     _image;

    private:
        // copy constructor and operator should not be called
        Buffer( const Buffer&, const osg::CopyOp& ) {}
        Buffer& operator=( const Buffer& copy ) { return (*this); }
    };

	/////////////////////////////////////////////////////////////////////////////////////////////////
	// PUBLIC FUNCTIONS /////////////////////////////////////////////////////////////////////////////
	/////////////////////////////////////////////////////////////////////////////////////////////////
	//------------------------------------------------------------------------------
	template< class DATATYPE >
	Buffer<DATATYPE>::Buffer()
		: osgCompute::Buffer(),
          osg::Object()
	{
		clearLocal();
	}

	//------------------------------------------------------------------------------
	template< class DATATYPE >
	void Buffer<DATATYPE>::clear()
	{
		clearLocal();
		osgCompute::Buffer::clear();
	}

    //------------------------------------------------------------------------------
    template< class DATATYPE >
    bool Buffer<DATATYPE>::init()
    {
        unsigned int numElements = 1;
        for( unsigned int d=0; d<osgCompute::Buffer::getNumDimensions(); ++d )
            numElements *= osgCompute::Buffer::getDimension( d );

        unsigned int byteSize = numElements * sizeof( DATATYPE );

        // check stream data
        if( _image.valid() )
        {
            if( _image->getNumMipmapLevels() > 1 )
            {
                osg::notify(osg::FATAL)
                    << "osgCuda::Buffer::init() for Buffer \""
                    << osg::Object::getName() <<"\": Image \""
                    << _image->getName() << "\" uses MipMaps which are currently"
                    << "not supported."
                    << std::endl;

                clear();
                return false;
            }

            if( _image->getTotalSizeInBytes() != byteSize )
            {
                osg::notify(osg::FATAL)
                    << "osgCuda::Buffer::init() for buffer \""
                    << osg::Object::getName() <<"\": size of image \""
                    << _image->getName() << "\" does not match the buffer size."
                    << std::endl;

                clear();
                return false;
            }
        }
        
        if( _array.valid() )
        {
            if( _array->getTotalDataSize() != byteSize )
            {
                osg::notify(osg::FATAL)
                    << "osgCuda::Buffer::init() for buffer \""
                    << osg::Object::getName() <<"\": size of array \""
                    << _array->getName() << "\" does not match with the buffer size."
                    << std::endl;

                clear();
                return false;
            }
        }

        return osgCompute::Buffer::init();
    }

	//------------------------------------------------------------------------------
	template< class DATATYPE >
	void* Buffer<DATATYPE>::map( const osgCompute::Context& context, unsigned int mapping ) const
	{
        if( osgCompute::Resource::isClear() )
        {
            osg::notify(osg::FATAL)
                << "osgCuda::Buffer::map() for buffer \""
                << osg::Object::getName() <<"\": buffer is dirty."
                << std::endl;

            return NULL;
        }

        if( static_cast<const Context*>(&context)->getAssignedThread() != OpenThreads::Thread::CurrentThread() )
        {
            osg::notify(osg::FATAL)
                << "osgCuda::Buffer::map() for Buffer \""
                << osg::Object::getName() <<"\": calling thread differs from the context's thread."
                << std::endl;

            return NULL;
        }

		BufferStream<DATATYPE>* stream = static_cast<BufferStream<DATATYPE>*>( osgCompute::Buffer::lookupStream(context) );
		if( NULL == stream )
		{
			osg::notify(osg::FATAL)
				<< "osgCuda::Buffer::map() for buffer \""
				<< osg::Object::getName() <<"\": could not receive BufferStream for context \""
				<< context.getId() << "\"."
				<< std::endl;

			return NULL;
		}

        DATATYPE* ptr = NULL;
        if( mapping != osgCompute::UNMAPPED )
            ptr = mapStream( *stream, mapping );
        else
            unmapStream( *stream );

        return ptr;
	}

    //------------------------------------------------------------------------------
    template< class DATATYPE >
    void Buffer<DATATYPE>::unmap( const osgCompute::Context& context ) const
    {
        if( osgCompute::Resource::isClear() )
        {
            osg::notify(osg::FATAL)
                << "osgCuda::Buffer::map() for buffer \""
                << osg::Object::getName() <<"\": buffer is dirty."
                << std::endl;

            return;
        }

        if( static_cast<const Context*>(&context)->getAssignedThread() != OpenThreads::Thread::CurrentThread() )
        {
            osg::notify(osg::FATAL)
                << "osgCuda::Buffer::map() for Buffer \""
                << osg::Object::getName() <<"\": calling thread differs from the context's thread."
                << std::endl;

            return;
        }

        BufferStream<DATATYPE>* stream = static_cast<BufferStream<DATATYPE>*>( osgCompute::Buffer::lookupStream(context) );
        if( NULL == stream )
        {
            osg::notify(osg::FATAL)
                << "osgCuda::Buffer::map() for buffer \""
                << osg::Object::getName() <<"\": could not receive BufferStream for context \""
                << context.getId() << "\"."
                << std::endl;

            return;
        }

        unmapStream( *stream );
    }

    //------------------------------------------------------------------------------
    template< class DATATYPE >
    bool osgCuda::Buffer<DATATYPE>::setMemory( const osgCompute::Context& context, int value, unsigned int mapping ) const
    {
        void* data = map( context, mapping );
        if( NULL == data )
            return false;

        if( mapping & osgCompute::MAP_HOST_TARGET )
        {
            if( NULL == memset( data, value, getByteSize() ) )
            {
                osg::notify(osg::FATAL)
                    << "osgCuda::Buffer::setMemory() for buffer \""
                    << osg::Object::getName() <<"\": memset() failed for host data within context \""
                    << context.getId() << "\"."
                    << std::endl;

                unmap( context );
                return false;
            }
        }
        else if( mapping & osgCompute::MAP_DEVICE_TARGET )
        {
            cudaError res = cudaMemset( data, value, getByteSize() );
            if( res != cudaSuccess )
            {
                osg::notify(osg::FATAL)
                    << "osgCuda::Buffer::setMemory() for buffer \""
                    << osg::Object::getName() <<"\": cudaMemset() failed for device data within context \""
                    << context.getId() << "\"."
                    << std::endl;


                unmap( context );
                return false;
            }
        }

        return true;
    }

    //------------------------------------------------------------------------------
    template< class DATATYPE >
    DATATYPE* Buffer<DATATYPE>::mapStream( BufferStream<DATATYPE>& stream, unsigned int mapping ) const
    {
        DATATYPE* ptr = NULL;

        bool needsSetup = false;
        if( (_image.valid() && _image->getModifiedCount() != stream._modifyCount ) ||
            (_array.valid() && _array->getModifiedCount() != stream._modifyCount ) )
            needsSetup = true;

        ///////////////////
        // PROOF MAPPING //
        ///////////////////
		if( ((stream._mapping & osgCompute::MAP_DEVICE && mapping & osgCompute::MAP_DEVICE) ||
			 (stream._mapping & osgCompute::MAP_HOST && mapping & osgCompute::MAP_HOST))  &&
			!needsSetup )
        {
            if( (stream._mapping & osgCompute::MAP_DEVICE) )
                ptr = stream._devPtr;
            else
                ptr = stream._hostPtr;

            if( osgCompute::Buffer::getSubloadResourceCallback() && NULL != ptr )
            {
                const osgCompute::BufferSubloadCallback* callback = 
                    dynamic_cast<const osgCompute::BufferSubloadCallback*>(osgCompute::Buffer::getSubloadResourceCallback());
                if( callback )
                {
                    // subload data before returning the pointer
                    callback->subload( ptr, mapping, *this, *stream._context );
                }
            }

			stream._mapping = mapping;
            return ptr;
        }
        else if( stream._mapping != osgCompute::UNMAPPED )
        {
            unmapStream( stream );
        }

        stream._mapping = mapping;

        //////////////
        // MAP DATA //
        //////////////
        bool firstLoad = false;
        if( (stream._mapping & osgCompute::MAP_HOST) )
        {
            if( NULL == stream._hostPtr )
            {
                //////////////////////////
                // ALLOCATE HOST-MEMORY //
                //////////////////////////
                if( !allocStream( mapping, stream ) )
                    return NULL;

                firstLoad = true;
            }

            //////////////////
            // SETUP STREAM //
            //////////////////
            if( needsSetup )
                if( !setupStream( mapping, stream ) )
                    return NULL;

            /////////////////
            // SYNC STREAM //
            /////////////////
            if( stream._syncHost && NULL != stream._devPtr )
                if( !syncStream( mapping, stream ) )
                    return NULL;

            ptr = stream._hostPtr;
        }
        else if( (stream._mapping & osgCompute::MAP_DEVICE) )
        {
            if( NULL == stream._devPtr )
            {
                ////////////////////////////
                // ALLOCATE DEVICE-MEMORY //
                ////////////////////////////
                if( !allocStream( mapping, stream ) )
                    return NULL;

                firstLoad = true;
            }

            //////////////////
            // SETUP STREAM //
            //////////////////
            if( needsSetup )
                if( !setupStream( mapping, stream ) )
                    return NULL;

            /////////////////
            // SYNC STREAM //
            /////////////////
            if( stream._syncDevice && NULL != stream._hostPtr )
                if( !syncStream( mapping, stream ) )
                    return NULL;

            ptr = stream._devPtr;
        }
        else
        {
            osg::notify(osg::WARN)
                << "osgCuda::Buffer::mapStream() for Buffer \""<< osg::Object::getName()<<"\": Wrong mapping. Use one of the following: "
                << "HOST_SOURCE, HOST_TARGET, HOST, DEVICE_SOURCE, DEVICE_TARGET, DEVICE."
                << std::endl;

            return NULL;
        }

        //////////////////
        // LOAD/SUBLOAD //
        //////////////////
        if( osgCompute::Buffer::getSubloadResourceCallback() && NULL != ptr )
        {
            const osgCompute::BufferSubloadCallback* callback = 
                dynamic_cast<const osgCompute::BufferSubloadCallback*>(osgCompute::Buffer::getSubloadResourceCallback());
            if( callback )
            {
                // load or subload data before returning the host pointer
                if( firstLoad )
                    callback->load( ptr, mapping, *this, *stream._context );
                else
                    callback->subload( ptr, mapping, *this, *stream._context );
            }
        }

        return ptr;
    }

    //------------------------------------------------------------------------------
    template< class DATATYPE >
    bool Buffer<DATATYPE>::setupStream( unsigned int mapping, BufferStream<DATATYPE>& stream ) const
    {
        cudaError res;

        if( mapping & osgCompute::MAP_DEVICE )
        {
            const void* data = NULL;
            if( _image.valid() )
            {
                data = _image->data();
            }
            
            if( _array.valid() )
            {
                data = reinterpret_cast<const void*>( _array->getDataPointer() );
            }

            if( data == NULL )
            {
                osg::notify(osg::FATAL)
                    << "osgCuda::Buffer::setupStream() for buffer \""<< osg::Object::getName()
                    << "\": Cannot receive valid data pointer."
                    << std::endl;

                return false;
            }

            res = cudaMemcpy( stream._devPtr,  data, osgCompute::Buffer::getByteSize(), cudaMemcpyHostToDevice );
            if( cudaSuccess != res )
            {
                osg::notify(osg::FATAL)
                    << "osgCuda::Buffer::setupStream() for buffer \""<< osg::Object::getName()
                    << "\": cudaMemcpy() failed for data within context \""
                    << stream._context->getId() << "\"." 
					<< cudaGetErrorString( res ) <<"."
                    << std::endl;

                return false;
            }

            // host must be synchronized
            stream._syncHost = true;
            stream._modifyCount = _image.valid()? _image->getModifiedCount() : _array->getModifiedCount();

            return true;
        }
        else if( mapping & osgCompute::MAP_HOST )
        {
            const void* data = NULL;
            if( _image.valid() )
            {
                data = _image->data();
            }

            if( _array.valid() )
            {
                data = reinterpret_cast<const void*>( _array->getDataPointer() );
            }

            if( data == NULL )
            {
                osg::notify(osg::FATAL)
                    << "osgCuda::Buffer::setupStream() for buffer \""<< osg::Object::getName()
                    << "\": Cannot receive valid data pointer."
                    << std::endl;

                return false;
            }

            res = cudaMemcpy( stream._hostPtr,  data, osgCompute::Buffer::getByteSize(), cudaMemcpyHostToHost );
            if( cudaSuccess != res )
            {
                osg::notify(osg::FATAL)
                    << "osgCuda::Buffer::setupStream() for buffer \""<< osg::Object::getName()
                    << "\": cudaMemcpy() failed for data within context \""
                    << stream._context->getId() << "\"." 
					<< cudaGetErrorString( res ) <<"."
                    << std::endl;

                return false;
            }

            // device must be synchronized
            stream._syncDevice = true;
            stream._modifyCount = _image.valid()? _image->getModifiedCount() : _array->getModifiedCount();
            
            return true;
        }

        return false;
    }

    //------------------------------------------------------------------------------
    template< class DATATYPE >
    bool Buffer<DATATYPE>::allocStream( unsigned int mapping, BufferStream<DATATYPE>& stream ) const
    {
        if( mapping & osgCompute::MAP_HOST )
        {
            if( stream._hostPtr != NULL )
                return true;

            if( (stream._allocHint & osgCompute::ALLOC_DYNAMIC) == osgCompute::ALLOC_DYNAMIC )
            {
                stream._hostPtr = reinterpret_cast<DATATYPE*>(
                    static_cast<Context*>(stream._context.get())->mallocDeviceHostMemory( osgCompute::Buffer::getByteSize() ) );
                if( NULL == stream._hostPtr )
                {
                    osg::notify(osg::FATAL)
                        << "osgCuda::Buffer::allocStream() for Buffer \""
                        << osg::Object::getName()<<"\": Something goes wrong within mallocDeviceHost() within Context \""<<stream._context->getId()
                        << "\"."
                        << std::endl;

                    return false;
                }
            }
            else
            {
                stream._hostPtr = reinterpret_cast<DATATYPE*>(
                    static_cast<Context*>(stream._context.get())->mallocHostMemory( osgCompute::Buffer::getByteSize() ) );
                if( NULL == stream._hostPtr )
                {
                    osg::notify(osg::FATAL)
                        << "osgCuda::Buffer::allocStream() for Buffer \""
                        << osg::Object::getName()<<"\": Something goes wrong within mallocHost() within Context \""<<stream._context->getId()
                        << "\"."
                        << std::endl;

                    return false;
                }
            }

            stream._hostPtrAllocated = true;
            if( stream._devPtr != NULL )
                stream._syncHost = true;
            return true;
        }
        else if( mapping & osgCompute::MAP_DEVICE )
        {
            if( stream._devPtr != NULL )
                return true;

            if( osgCompute::Buffer::getNumDimensions() == 3 )
            {
                stream._devPtr = reinterpret_cast<DATATYPE*>(
                            static_cast<Context*>(stream._context.get())->mallocDevice3DMemory(
                            osgCompute::Buffer::getDimension(0) * sizeof(DATATYPE),
                            osgCompute::Buffer::getDimension(1),
                            osgCompute::Buffer::getDimension(2)) );

                if( NULL == stream._devPtr )
                {
                    osg::notify(osg::FATAL)
                        << "osgCuda::Buffer::allocStream() for Buffer \""<< osg::Object::getName()<<"\": Something goes wrong within mallocDevice3D() within Context \""
                        << stream._context->getId() << "\"."
                        << std::endl;

                    return false;
                }
            }
            else if( osgCompute::Buffer::getNumDimensions() == 2 )
            {
                stream._devPtr = reinterpret_cast<DATATYPE*>(
                    static_cast<Context*>(stream._context.get())->mallocDevice2DMemory(
                    osgCompute::Buffer::getDimension(0) * sizeof(DATATYPE),
                    osgCompute::Buffer::getDimension(1)) );

                if( NULL == stream._devPtr )
                {
                    osg::notify(osg::FATAL)
                        << "osgCuda::Buffer::allocStream() for Buffer \""<< osg::Object::getName()<<"\": Something goes wrong within mallocDevice2D() within Context \""
                        << stream._context->getId() << "\"."
                        << std::endl;

                    return false;
                }
            }
            else
            {
                 stream._devPtr = reinterpret_cast<DATATYPE*>(
                        static_cast<Context*>(stream._context.get())->mallocDeviceMemory(
                        osgCompute::Buffer::getByteSize())  );
                 if( NULL == stream._devPtr )
                 {
                     osg::notify(osg::FATAL)
                         << "osgCuda::Buffer::allocStream() for Buffer \""<< osg::Object::getName()<<"\": Something goes wrong within mallocDevice() within Context \""
                         << stream._context->getId() << "\"."
                         << std::endl;

                     return false;
                 }
            }

            stream._devPtrAllocated = true;

            if( stream._hostPtr != NULL )
                stream._syncDevice = true;
            return true;
        }

        return false;
    }

    //------------------------------------------------------------------------------
    template< class DATATYPE >
    bool Buffer<DATATYPE>::syncStream( unsigned int mapping, BufferStream<DATATYPE>& stream ) const
    {
        cudaError res;
        if( mapping & osgCompute::MAP_DEVICE )
        {
            res = cudaMemcpy( stream._devPtr, stream._hostPtr, osgCompute::Buffer::getByteSize(), cudaMemcpyHostToDevice );
            if( cudaSuccess != res )
            {
                osg::notify(osg::FATAL)
                    << "osgCuda::Buffer::syncStream() for Buffer \""<< osg::Object::getName()
                    << "\": Something goes wrong on cudaMemcpy() to device within Context \""
                    << stream._context->getId() << "\"."
                    << cudaGetErrorString( res ) <<"."
                    << std::endl;
                return false;
            }

            stream._syncDevice = false;
            return true;
        }
        else if( mapping & osgCompute::MAP_HOST )
        {
            res = cudaMemcpy( stream._hostPtr, stream._devPtr, osgCompute::Buffer::getByteSize(), cudaMemcpyDeviceToHost );
            if( cudaSuccess != res )
            {
                osg::notify(osg::FATAL)
                    << "osgCuda::Buffer::syncStream() for Buffer \""
                    << osg::Object::getName()<<"\": Something goes wrong within cudaMemcpy() to host within Context \""
                    << stream._context->getId() << "\"."
                    << cudaGetErrorString( res ) <<"."
                    << std::endl;

                return false;
            }

            stream._syncHost = false;
            return true;
        }

        return false;
    }

    //------------------------------------------------------------------------------
    template< class DATATYPE >
    void Buffer<DATATYPE>::unmapStream( BufferStream<DATATYPE>& stream ) const
    {
        if( (stream._mapping & osgCompute::MAP_HOST_TARGET) )
        {
            stream._syncDevice = true;
        }
        else if( (stream._mapping & osgCompute::MAP_DEVICE_TARGET) )
        {
            stream._syncHost = true;
        }

        stream._mapping = osgCompute::UNMAPPED;
    }

	//------------------------------------------------------------------------------
	template< class DATATYPE >
    void Buffer<DATATYPE>::setImage( osg::Image* image )
	{
        if( !osgCompute::Resource::isClear() && image != NULL )
        {
            if( image->getNumMipmapLevels() > 1 )
            {
                osg::notify(osg::FATAL)
                    << "osgCuda::Buffer::setupStream() for buffer \""
                    << osg::Object::getName() <<"\": image \""
                    << image->getName() << "\" uses MipMaps which are currently"
                    << "not supported."
                    << std::endl;

                return;
            }

            if( image->getTotalSizeInBytes() != osgCompute::Buffer::getByteSize() )
            {
                osg::notify(osg::FATAL)
                    << "osgCuda::Buffer::setupStream() for buffer \""
                    << osg::Object::getName() <<"\": size of image \""
                    << image->getName() << "\" does not match the buffer size."
                    << std::endl;

                return;
            }
        }

        _image = image;
        _array = NULL;
	}

    //------------------------------------------------------------------------------
    template< class DATATYPE >
    osg::Image* Buffer<DATATYPE>::getImage()
    {
        return _image.get();
    }

    //------------------------------------------------------------------------------
    template< class DATATYPE >
    const osg::Image* Buffer<DATATYPE>::getImage() const
    {
        return _image.get();
    }

    //------------------------------------------------------------------------------
    template< class DATATYPE >
    void Buffer<DATATYPE>::setArray( osg::Array* array )
    {
        if( !osgCompute::Resource::isClear() && array != NULL )
        {
            if( array->getTotalDataSize() != osgCompute::Buffer::getByteSize() )
            {
                osg::notify(osg::FATAL)
                    << "osgCuda::Buffer::setArray() for buffer \""
                    << osg::Object::getName() <<"\": size of array \""
                    << array->getName() << "\" does not match with the buffer size."
                    << std::endl;

                return;
            }
        }

        _array = array;
        _image = NULL;
    }

    //------------------------------------------------------------------------------
    template< class DATATYPE >
    osg::Array* Buffer<DATATYPE>::getArray()
    {
        return _array.get();
    }

    //------------------------------------------------------------------------------
    template< class DATATYPE >
    const osg::Array* Buffer<DATATYPE>::getArray() const
    {
        return _array.get();
    }

    /////////////////////////////////////////////////////////////////////////////////////////////////
    // PROTECTED FUNCTIONS //////////////////////////////////////////////////////////////////////////
    /////////////////////////////////////////////////////////////////////////////////////////////////
    //------------------------------------------------------------------------------
    template< class DATATYPE >
    void Buffer<DATATYPE>::clearLocal()
    {
        _array = NULL;
        _image = NULL;
    }

    //------------------------------------------------------------------------------
    template< class DATATYPE >
    osgCompute::BufferStream* Buffer<DATATYPE>::newStream( const osgCompute::Context& context ) const
    {
        return new BufferStream<DATATYPE>;
    }
}

#endif //OSGCUDA_BUFFER
