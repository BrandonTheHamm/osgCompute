/* osgCompute - Copyright (C) 2008-2009 SVT Group
*
* This library is free software; you can redistribute it and/or modify
* it under the terms of the GNU Lesser General Public License as
* published by the Free Software Foundation; either version 3 of
* the License, or (at your option) any later version.
*
* This library is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU Lesse General Public License for more details.
*
* The full license is in LICENSE file included with this distribution.
*/

#ifndef OSGCUDA_BUFFER
#define OSGCUDA_BUFFER 1


#include <osg/Image>
#include <osg/Array>
#include <osgCompute/Memory>
#include <osgCuda/Export>

namespace osgCuda
{
    /**
    */
    class BufferObject : public osgCompute::MemoryObject
    {
    public:
        void*							_devPtr;
        void*							_hostPtr;
        unsigned int                    _modifyCount;

        BufferObject();
        virtual ~BufferObject();

    private:
        // not allowed to call copy-constructor or copy-operator
        BufferObject( const BufferObject& ) {}
        BufferObject& operator=( const BufferObject& ) { return *this; }
    };

    /**
    */
    class LIBRARY_EXPORT Buffer : public osgCompute::Memory
    {
    public:
        Buffer();

        META_Object(osgCuda,Buffer)

        virtual bool init();
        virtual void clear();

        virtual void* map( unsigned int mapping = osgCompute::MAP_DEVICE, unsigned int offset = 0, unsigned int hint = 0 );
        virtual void unmap( unsigned int hint = 0 );
        virtual bool reset( unsigned int hint = 0 );
        virtual bool isMappingAllowed( unsigned int mapping, unsigned int hint = 0 ) const;

        virtual void setImage( osg::Image* image );
        virtual osg::Image* getImage();
        virtual const osg::Image* getImage() const;

        virtual void setArray( osg::Array* array );
        virtual osg::Array* getArray();
        virtual const osg::Array* getArray() const;

    protected:
        virtual ~Buffer() { clearLocal(); }
        void clearLocal();


        bool setup( unsigned int mapping );
        bool alloc( unsigned int mapping );
        bool sync( unsigned int mapping );

        virtual osgCompute::MemoryObject* createObject() const;
        virtual unsigned int computePitch() const;
        void resetModifiedCounts() const;

    protected:
        mutable osg::ref_ptr<osg::Array>     _array;
        mutable osg::ref_ptr<osg::Image>     _image;

    private:
        // copy constructor and operator should not be called
        Buffer( const Buffer&, const osg::CopyOp& ) {}
        Buffer& operator=( const Buffer& copy ) { return (*this); }
    };
}

#endif //OSGCUDA_BUFFER
