/* osgCompute - Copyright (C) 2008-2009 SVT Group
 *                                                                     
 * This library is free software; you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 3 of
 * the License, or (at your option) any later version.
 *                                                                     
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of 
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesse General Public License for more details.
 *
 * The full license is in LICENSE file included with this distribution.
*/

#ifndef OSGCOMPUTE_BUFFER
#define OSGCOMPUTE_BUFFER 1

#include <osgCompute/Resource>

#define META_Buffer( libraryname, classname )                           \
    META_Resource( libraryname, classname, false )                      

namespace osg
{
    class Image;
    class Vec2b;
    class Vec3b;
    class Vec4b;
    class Vec4ub;
    class Vec2s;
    class Vec3s;
    class Vec4s;
    class Vec2f;
    class Vec3f;
    class Vec4f;
    class Vec2d;
    class Vec3d;
    class Vec4d;
}

namespace osgCompute
{
    template< class DATATYPE > class Buffer;

    typedef Buffer<unsigned char>     UByteBuffer;
    typedef Buffer<osg::Vec4ub>       Vec4ubBuffer;
    typedef Buffer<char>              ByteBuffer;
    typedef Buffer<osg::Vec2b>        Vec2bBuffer;
    typedef Buffer<osg::Vec3b>        Vec3bBuffer;
    typedef Buffer<osg::Vec4b>        Vec4bBuffer;
    typedef Buffer<unsigned short>    UShortBuffer;
    typedef Buffer<short>             ShortBuffer;
    typedef Buffer<osg::Vec2s>        Vec2sBuffer;
    typedef Buffer<osg::Vec3s>        Vec3sBuffer;
    typedef Buffer<osg::Vec4s>        Vec4sBuffer;
    typedef Buffer<unsigned int>      UIntBuffer;
    typedef Buffer<int>               IntBuffer;
    typedef Buffer<unsigned long>     ULongBuffer;
    typedef Buffer<long>              LongBuffer;
    typedef Buffer<float>             FloatBuffer;
    typedef Buffer<osg::Vec2f>        Vec2fBuffer;
    typedef Buffer<osg::Vec3f>        Vec3fBuffer;
    typedef Buffer<osg::Vec4f>        Vec4fBuffer;
    typedef Buffer<double>            DoubleBuffer;
    typedef Buffer<osg::Vec2d>        Vec2dBuffer;
    typedef Buffer<osg::Vec3d>        Vec3dBuffer;
    typedef Buffer<osg::Vec4d>        Vec4dBuffer;

    enum Mapping
    {
        UNMAPPED                       = 0x00000000,
        MAP_HOST                       = 0x00000011,
        MAP_HOST_SOURCE                = 0x00000001,
        MAP_HOST_TARGET                = 0x00000010,
        MAP_DEVICE                     = 0x00110000,
        MAP_DEVICE_SOURCE              = 0x00010000,
        MAP_DEVICE_TARGET              = 0x00100000,
    }; 


    enum ALLOC_HINT
    {
        NO_ALLOC_HINT = 0x0,
        ALLOC_DYNAMIC = 0x1
    };

    /**
    */
    template< class DATATYPE >
    class BufferStream
    {
    public:
        unsigned int                    _mapping;
        osg::ref_ptr<Context>           _context;
        unsigned int                    _allocHint;
        bool                            _needsSetup;

        BufferStream();
        virtual ~BufferStream();

    private:
        // not allowed to call copy-constructor or copy-operator
        BufferStream( const BufferStream& ) {}
        BufferStream& operator=( const BufferStream& ) { return *this; }
    };

    /////////////////////////////////////////////////////////////////////////////////////////////////
    // PUBLIC FUNCTIONS /////////////////////////////////////////////////////////////////////////////
    /////////////////////////////////////////////////////////////////////////////////////////////////
    //------------------------------------------------------------------------------
    template< class DATATYPE >
    BufferStream<DATATYPE>::BufferStream() 
        :   _mapping( UNMAPPED ),
            _allocHint(0),
            _needsSetup(true)
    {
    }

    //------------------------------------------------------------------------------
    template< class DATATYPE >
    BufferStream<DATATYPE>::~BufferStream() 
    {
    }

    /**
    */
    template< class DATATYPE >
    class Buffer : public Resource
    {  
    public:
        Buffer();

        virtual bool init();
        virtual void clear();

        virtual bool setMemory( const Context& context, int value, unsigned int mapping ) const = 0;
        virtual void* map( const Context& context, unsigned int mapping ) const = 0;
        virtual void unmap( const Context& context ) const = 0;

        virtual unsigned int getByteSize() const;
        virtual unsigned int getElementSize() const;

        inline void setDimension( unsigned int dimIdx, unsigned int dimSize );
        inline unsigned int getDimension( unsigned int dimIdx ) const;
        inline unsigned int getNumDimensions() const;

        inline unsigned int getNumElements() const;

        inline void setAllocHint( unsigned int allocHint );
        inline unsigned int getAllocHint() const;

        virtual unsigned int getMapping( const Context& context ) const;

        inline void setSubloadResourceCallback( SubloadCallback* sc );
        inline SubloadCallback* getSubloadResourceCallback();
        inline const SubloadCallback* getSubloadResourceCallback() const;

    protected:
        virtual ~Buffer() { clearLocal(); }
        inline void clearLocal();

        virtual bool init( const Context& context ) const;
        virtual void clear( const Context& context ) const;

        virtual BufferStream<DATATYPE>* newStream( const Context& context ) const = 0;
        inline BufferStream<DATATYPE>* lookupStream( const Context& context ) const;

        virtual void setNeedsSetup( bool needsSetup ) const;

        unsigned int                                    _allocHint;
		unsigned int							        _byteSize;
        std::vector<unsigned int>                       _dimensions;
        unsigned int                                    _numElements;
        osg::ref_ptr<SubloadCallback>                   _subloadCallback;

        mutable OpenThreads::Mutex                      _mutex;
        mutable std::vector<BufferStream<DATATYPE>*>    _streams;

    private:
        // copy constructor and operator should not be called
        Buffer( const Buffer&, const osg::CopyOp& ) {}
        Buffer& operator=( const Buffer& copy ) { return (*this); }
    };

	/////////////////////////////////////////////////////////////////////////////////////////////////
	// PUBLIC FUNCTIONS /////////////////////////////////////////////////////////////////////////////
	/////////////////////////////////////////////////////////////////////////////////////////////////
    //------------------------------------------------------------------------------
    template< class DATATYPE >
	Buffer<DATATYPE>::Buffer() 
		: Resource()
	{ 
		clearLocal();
	}

    //------------------------------------------------------------------------------
    template<class DATATYPE >
	void Buffer<DATATYPE>::clear()
	{
        Resource::clear();
        clearLocal();
	}

    //------------------------------------------------------------------------------
    template< class DATATYPE >
	bool Buffer<DATATYPE>::init()
	{
		if( !isDirty() )
			return true;

		if( _dimensions.empty() )
		{
			osg::notify(osg::FATAL)  
                << "Buffer::init() for Buffer \""<<asObject()->getName()<<"\": No Dimensions specified."                  
				<< std::endl;

			return false;
		}

		///////////////////////
		// COMPUTE BYTE SIZE //
		///////////////////////
		_numElements = 1;
		for( unsigned int d=0; d<_dimensions.size(); ++d )
			_numElements *= _dimensions[d];

		_byteSize = sizeof(DATATYPE) * _numElements;

		return Resource::init();
	}

	//------------------------------------------------------------------------------
	template< class DATATYPE >
	unsigned int Buffer<DATATYPE>::getByteSize() const 
	{ 
		return _byteSize; 
	}

    //------------------------------------------------------------------------------
    template< class DATATYPE >
    unsigned int Buffer<DATATYPE>::getElementSize() const 
    { 
        return sizeof(DATATYPE); 
    }

	//------------------------------------------------------------------------------
	template< class DATATYPE >
    inline void Buffer<DATATYPE>::setDimension( unsigned int dimIdx, unsigned int dimSize )
    {
        if( !isDirty() )
            return;

        if (_dimensions.size()<=dimIdx)
            _dimensions.resize(dimIdx+1,0);

        _dimensions[dimIdx] = dimSize;
    }

	//------------------------------------------------------------------------------
	template< class DATATYPE >
    inline unsigned int Buffer<DATATYPE>::getDimension( unsigned int dimIdx ) const
    { 
        if( dimIdx > (_dimensions.size()-1) )
            return 0;

        return _dimensions[dimIdx];
    }

	//------------------------------------------------------------------------------
	template< class DATATYPE >
    inline unsigned int Buffer<DATATYPE>::getNumDimensions() const
    { 
        return _dimensions.size();
    }

    //------------------------------------------------------------------------------
    template< class DATATYPE >
    unsigned int osgCompute::Buffer<DATATYPE>::getNumElements() const
    {
        return _numElements;
    }

    //------------------------------------------------------------------------------
    template< class DATATYPE >
    inline void osgCompute::Buffer<DATATYPE>::setAllocHint( unsigned int allocHint )
    {
        if( !isDirty() )
            return;

        _allocHint = (_allocHint | allocHint);
    }

    //------------------------------------------------------------------------------
    template< class DATATYPE >
    inline unsigned int osgCompute::Buffer<DATATYPE>::getAllocHint() const
    {
        return _allocHint;
    }

    //------------------------------------------------------------------------------
    template< class DATATYPE >
    unsigned int Buffer<DATATYPE>::getMapping( const osgCompute::Context& context ) const
    {
        if( isDirty() )
            return osgCompute::UNMAPPED;

        BufferStream<DATATYPE>* stream = lookupStream( context );
        if( NULL == stream )
        {
            osg::notify(osg::FATAL)  
                << "Buffer::getMapping() for Buffer \""
                << asObject()->getName() <<"\": Could not receive BufferStream for Context \""
                << context.getId() << "\"."
                << std::endl;

            return osgCompute::UNMAPPED;
        }

        return stream->_mapping;
    }

    //------------------------------------------------------------------------------
    template< class DATATYPE >
    inline void Buffer<DATATYPE>::setSubloadResourceCallback( SubloadCallback* sc ) 
    { 
        _subloadCallback = sc; 
    }

    //------------------------------------------------------------------------------
    template< class DATATYPE >
    inline SubloadCallback* Buffer<DATATYPE>::getSubloadResourceCallback() 
    { 
        return _subloadCallback.get(); 
    }

    //------------------------------------------------------------------------------
    template< class DATATYPE >
    inline const SubloadCallback* Buffer<DATATYPE>::getSubloadResourceCallback() const 
    { 
        return _subloadCallback.get(); 
    }

    /////////////////////////////////////////////////////////////////////////////////////////////////
    // PROTECTED FUNCTIONS //////////////////////////////////////////////////////////////////////////
    /////////////////////////////////////////////////////////////////////////////////////////////////
    //------------------------------------------------------------------------------
    template< class DATATYPE >
    void Buffer<DATATYPE>::clearLocal()
    {
        _streams.clear();
        _dimensions.clear();
        _numElements = 0;
        _byteSize = 0;
        _allocHint = NO_ALLOC_HINT;
        _subloadCallback = NULL;
    }

    //------------------------------------------------------------------------------
    template< class DATATYPE >
    bool Buffer<DATATYPE>::init( const Context& context ) const
    {
        if( _streams.size()<=context.getId() )
            _streams.resize(context.getId()+1,NULL);

        // Allocate stream array for context
        if( NULL == _streams[context.getId()] )
        {
            _streams[context.getId()] = newStream( context );

            if( NULL == _streams[context.getId()] )
            {
                osg::notify( osg::FATAL )  
                    << "Buffer::init( \"CONTEXT\" ) for Buffer \"" << asObject()->getName()
                    << "\": DataArray could be allocated for context \"" 
                    << context.getId() << "\"."
                    << std::endl;

                return false;
            }

            _streams[context.getId()]->_context = const_cast<osgCompute::Context*>( &context );
            _streams[context.getId()]->_allocHint = getAllocHint();
        }

        // Register param if valid stream-array 
        // is allocated
        return Resource::init( context );
    }

    //------------------------------------------------------------------------------
    template< class DATATYPE >
    void Buffer<DATATYPE>::clear( const Context& context ) const
    {
        if( _streams.size() > context.getId() &&
            NULL != _streams[context.getId()] )
        {
            // delete stream
            delete _streams[context.getId()];
            _streams[context.getId()] = NULL;
        }

        // Unregister context
        return Resource::clear( context );
    }

    //------------------------------------------------------------------------------
    template< class DATATYPE >
    inline BufferStream<DATATYPE>* Buffer<DATATYPE>::lookupStream( const Context& context ) const
    {
        OpenThreads::ScopedLock<OpenThreads::Mutex> lock(_mutex);

        /////////////////////
        // ALLOCATE STREAM //
        /////////////////////
        // Init stream array and register at context
        if( _streams.size()<=context.getId() ||
            _streams[context.getId()] == NULL )
            init( context );

        return _streams[context.getId()];
    }

    //------------------------------------------------------------------------------
    template< class DATATYPE >
    void Buffer<DATATYPE>::setNeedsSetup( bool needsSetup ) const
    {
        OpenThreads::ScopedLock<OpenThreads::Mutex> lock(_mutex);
        for( unsigned int c=0; c<_streams.size(); ++c )
            _streams[c]->_needsSetup = needsSetup;
    }
}

#endif //OSGCOMPUTE_BUFFER
