/* osgCompute - Copyright (C) 2008-2009 SVT Group
 *                                                                     
 * This library is free software; you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 3 of
 * the License, or (at your option) any later version.
 *                                                                     
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of 
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesse General Public License for more details.
 *
 * The full license is in LICENSE file included with this distribution.
*/

#ifndef OSGCOMPUTE_PROCESSOR
#define OSGCOMPUTE_PROCESSOR 1

#include <map>
#include <osg/Node>
#include "osgCompute/ProcessorBin"

namespace osg
{
    class NodeVisitor;
}

/**
An helper macro
*/
#define META_Processor( asobject, asnode, binlibrary, binclass, ctxlibrary, ctxclass )               \
    virtual osg::Object*                asObject() { return asobject; }                             \
    virtual const osg::Object*          asObject() const { return asobject; }                       \
    virtual osg::Node*                  asNode() { return asnode; }                                 \
    virtual const osg::Node*            asNode() const { return asnode; }                           \
    virtual bool                        isNode() const { return (asnode != NULL); }                 \
    virtual osgCompute::ProcessorBin*    newProcessorBin() const { return new binlibrary::binclass; } \
    virtual std::string                 contextLibraryName() const { return #ctxlibrary; }          \
    virtual std::string                 contextClassName() const { return #ctxclass; }


namespace osgCompute
{
    class Redirection;
    class ProcessorBin;

    /**
    */
    class LIBRARY_EXPORT Processor : public osg::Node
    {
    public:
        Processor();

        virtual void accept( osg::NodeVisitor& nv );

        virtual osg::Object* asObject() = 0;
        virtual const osg::Object* asObject() const = 0;
        virtual osg::Node* asNode() = 0;
        virtual const osg::Node* asNode() const = 0;
        virtual bool isNode() const = 0;
        virtual std::string contextLibraryName() const = 0;
        virtual std::string contextClassName() const = 0;

        virtual void loadModule( const std::string& modName );
        virtual void addModule( Module& module );
        virtual void removeModule( Module& module );
        virtual void removeModule( const std::string& moduleName );
        virtual bool hasModule( const std::string& moduleName ) const;
        virtual bool hasModule( Module& module ) const;
        virtual bool hasModules() const;
        virtual Module* getModule( const std::string& moduleName );
        virtual const Module* getModule( const std::string& moduleName ) const;
        virtual ModuleList* getModules();
        virtual const ModuleList* getModules() const;
        virtual unsigned int getNumModules() const;

        virtual void addParamHandle( const std::string& handle, osgCompute::Param& param );
        virtual void removeParamHandle( const std::string& handle );
        virtual bool hasParamHandle( const std::string& handle ) const;
        virtual HandleToParamMap* getParamHandles();
        virtual const HandleToParamMap* getParamHandles() const;

        virtual void clearBins();
        virtual void enableBins();
        virtual void disableBins();

        inline void setLaunchCallback( LaunchCallback* lc );
        inline LaunchCallback* getLaunchCallback();
        inline const LaunchCallback* getLaunchCallback() const;

        virtual void clear();

    protected:
        virtual ~Processor() { clearLocal(); }
        void clearLocal();

        virtual void update( osg::NodeVisitor& uv );
        virtual void handleevent( osg::NodeVisitor& ev );

        virtual void checkTraversalModules();

        virtual ProcessorBin* newProcessorBin() const = 0;

        virtual Context* getOrCreateContext( osg::State& state );
        virtual ProcessorBin* getOrCreateProcessorBin( osg::NodeVisitor& nv );
     
        LaunchCallback*                     _launchCallback; 
        ModuleList                          _modules;
        HandleToParamMap                    _paramHandles;

        mutable OpenThreads::Mutex          _mutex;
        mutable BinMap                      _bins;

    private:
        // copy constructor and operator should not be called
        Processor( const Processor& ) {}
        Processor &operator=(const Processor &) { return *this; }
    };

    /////////////////////////////////////////////////////////////////////////////////////////////////
    // PUBLIC FUNCTIONS /////////////////////////////////////////////////////////////////////////////
    /////////////////////////////////////////////////////////////////////////////////////////////////
    //------------------------------------------------------------------------------
    inline void Processor::setLaunchCallback( LaunchCallback* lc ) 
    { 
        if( lc == _launchCallback )
            return;

        _launchCallback = lc; 
        clearBins();
    }

    //------------------------------------------------------------------------------
    inline LaunchCallback* Processor::getLaunchCallback() 
    { 
        return _launchCallback; 
    }

    //------------------------------------------------------------------------------
    inline const LaunchCallback* Processor::getLaunchCallback() const 
    { 
        return _launchCallback; 
    }
}

#endif //OSGCOMPUTE_PROCESSOR
