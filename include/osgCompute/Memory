/* osgCompute - Copyright (C) 2008-2009 SVT Group
*                                                                     
* This library is free software; you can redistribute it and/or modify
* it under the terms of the GNU Lesser General Public License as
* published by the Free Software Foundation; either version 3 of
* the License, or (at your option) any later version.
*                                                                     
* This library is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of 
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU Lesse General Public License for more details.
*
* The full license is in LICENSE file included with this distribution.
*/

#ifndef OSGCOMPUTE_BUFFER
#define OSGCOMPUTE_BUFFER 1

#include <osgCompute/Resource>                 

namespace osgCompute
{
    class Memory;

    enum SyncOperation
    {
        NO_SYNC     = 0x000,
        SYNC_DEVICE = 0x010,
        SYNC_HOST   = 0x001,
        SYNC_ARRAY  = 0x100,
    };

    enum Mapping
    {
        UNMAP                       = 0x00000000,
        MAP_HOST                    = 0x00000011,
        MAP_HOST_SOURCE             = 0x00000001,
        MAP_HOST_TARGET             = 0x00000010,
        MAP_DEVICE                  = 0x00110000,
        MAP_DEVICE_SOURCE           = 0x00010000,
        MAP_DEVICE_TARGET           = 0x00100000,
        MAP_DEVICE_ARRAY            = 0x00001000,
    }; 

    //! A MemoryObject provides internal information about the memory resources of a memory area on the device.
    /** 
    Every time a buffer is mapped an object of this type is created. All allocations are done lazily
    at the time Memory::map is called. You can remove the handle by calling Memory::clear(). However, as a 
    normal user you should never get into contact with MemoryObjects. Such objects are hidden from application developers. 
    MemoryObjects are created on the heap.
    */
    class LIBRARY_EXPORT MemoryObject : public osg::Referenced
    {
    public:
        //! The current mapping. Value is set before leaving the mapping function (See Memory::map).
        unsigned int                    _mapping;	
        //! The allocation hint used during allocation of the stream.
        unsigned int                    _allocHint; 
        //! The synchronize operation   
        unsigned int                    _syncOp;
        //! The current pitch: The BYTE size of a ROW in the memory.
        unsigned int                    _pitch;

        //! The constructor sets up the initial default values.
        MemoryObject();
        //! The destructor frees the related memory
        virtual ~MemoryObject();

    private:
        //! Its not allowed to call copy-operator
        MemoryObject( const MemoryObject& ) : Referenced(), _mapping(UNMAP), _allocHint(0), _syncOp(NO_SYNC) {}
        //! Its not allowed to call copy-constructor
        MemoryObject& operator=( const MemoryObject& ) { return *this; }
    };

    //! Memories allow developers to deal with memory resources on an abstract level.
    /**
    A buffer handles device memory as well as host memory. At least you have to specify the dimensions of a buffer and
    the size of a single element. The following example shows how to setup a 1D buffer with 125000 floats: 
    \code
    someMemory->setDimension( 0, 125000 );
    someMemory->setElementSize( sizeof(float) );
    \endcode
    At any time when you call the mapping function (Memory::map) the respective memory block then is allocated lazily 
    within the desired memory space. So in order to allocate the buffer on the device memory just use one of the following
    function calls:
    \code
    void* devPtr = someMemory->map( context, osgCompute::MAP_DEVICE );
    // or as osgCompute::MAP_DEVICE is the default paramter...
    void* devPtr = someMemory->map( context );
    // or access the buffer with an offset of 120000 bytes
    void* devPtr = someMemory->map( context, osgCompute::MAP_DEVICE, 120000 );
    \endcode
    */
    class LIBRARY_EXPORT Memory : public Resource
    {  
    public:
        //! calls clearLocal() which initializes the default values
        Memory();

        virtual bool init();

        /***/
        virtual void* map( unsigned int mapping = MAP_DEVICE, unsigned int offset = 0, unsigned int hint = 0 ) = 0;
        virtual void unmap( unsigned int hint = 0 ) = 0;
        virtual bool reset( unsigned int hint = 0  ) = 0;
        virtual bool isMappingAllowed( unsigned int mapping, unsigned int hint = 0 ) const = 0;
        virtual unsigned int getMapping( unsigned int hint = 0 ) const;
        virtual unsigned int getPitch( unsigned int hint = 0 ) const;

        virtual void setElementSize( unsigned int elementSize );
        virtual unsigned int getElementSize() const;
        virtual unsigned int getByteSize() const;

        virtual void setDimension( unsigned int dimIdx, unsigned int dimSize );
        virtual unsigned int getDimension( unsigned int dimIdx ) const;
        virtual unsigned int getNumDimensions() const;
        virtual unsigned int getNumElements() const;


        virtual void setAllocHint( unsigned int allocHint );
        virtual unsigned int getAllocHint() const;

        virtual void setSubloadCallback( SubloadCallback* sc );
        virtual SubloadCallback* getSubloadCallback();
        virtual const SubloadCallback* getSubloadCallback() const;

        virtual void swap( unsigned int incr = 1 );
        virtual unsigned int getSwapIdx() const;
        virtual unsigned int getSwapCount() const;

        virtual void clear();
        virtual void clearCurrent();
    protected:
        virtual ~Memory();
        void clearLocal();

        virtual MemoryObject* object();
        virtual const MemoryObject* object() const;
        virtual MemoryObject* createObject() const;
        virtual unsigned int computePitch() const = 0;

        unsigned int                                        _allocHint;
        std::vector<unsigned int>                           _dimensions;
        unsigned int                                        _numElements;
        unsigned int									    _elementSize;
        mutable unsigned int                                _pitch;
        osg::ref_ptr<SubloadCallback>                       _subloadCallback;

        mutable std::vector< osg::ref_ptr<MemoryObject> >   _objects;

    private:
        // copy constructor and operator should not be called
        Memory( const Memory&, const osg::CopyOp& ) {}
        Memory& operator=( const Memory& copy ) { return (*this); }
    };
}

#endif //OSGCOMPUTE_BUFFER
